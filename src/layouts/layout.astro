---
import '@/stylesheets/vars.scss';
import '@/stylesheets/global.scss';

import Header from '@/partials/header/Header.astro';
import Footer from '@/partials/footer/Footer.astro';
import Timeline from '@/components/blocks/timeline/timeline.astro';

// Layout props
const {
  title = "Astro Tailwind",
  description = "Servizi di trasporto professionali per aziende",
  activeLink = "home",
  bodyClass = ""
} = Astro.props;
---

<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content={description}>
  <title>{title}</title>

  <link rel="stylesheet" href="https://use.typekit.net/het3jqh.css">

  <link rel="stylesheet" href="/styles/tailwind.css">
</head>
<body class=`flex flex-col min-h-screen ${bodyClass}`>
  <!-- Inserisce direttamente il componente Header -->
  <Header activeLink={activeLink} />

  <!-- Contenuto principale -->
  <main class="flex-grow">
    <slot />
    <Timeline/>
  </main>

  <!-- Inserisce direttamente il componente Footer -->
  <Footer />


  <script>
import { progress } from "motion";

    // helper clamp function
    const clamp = (value, min, max) => {
     return(Math.min(Math.max(min, value), max));
    }

    const getScrollProgress = (element, threshold, containerHeightMultiplier = 1) => {
      const rect = element.getBoundingClientRect();

      // grab element info
      let top = rect.top;
      let bottom = rect.bottom;
      let height = (bottom - top);
      
      // rielaborate accounting for height multiplier
      top -= height * 0.5 * (containerHeightMultiplier -  1);
      bottom += height * 0.5 * (containerHeightMultiplier -  1);
      height *= containerHeightMultiplier;
      
      // calculate progress
      return(clamp((threshold - top) / height, 0, 1));
    }
    
    document.addEventListener("DOMContentLoaded", () => {
      const scrollingTexts = document.querySelectorAll('section.scrolling-text');
      const expandingImages = document.querySelectorAll('section.image.expanding .image-container');
      const sliders = document.querySelectorAll('section.slider');

      const scrollAnimations = () => {

        // Scrolling texts
        scrollingTexts.forEach(scrollingText => {
            const words = scrollingText.querySelectorAll('section.scrolling-text .content-text>span');
            const progressLength = 1 / words.length;
            const content = scrollingText.querySelector('.content-text');
            const progress = getScrollProgress(content, window.innerHeight / 2, 1.5);

            for(let i = 0; i < words.length; i++) {
              const word = words[i] as HTMLElement;
              const min = progressLength * i - progressLength * 3;
              const max = progressLength * i;
              word.style.opacity = 0.3 + clamp(((progress * 1.4 - 0.2) - min) / (max - min), 0, 1) * 0.7 + "";
            }
        });

        // Scrolling images
        expandingImages.forEach(image => {
          const container = image.querySelector('figure');
          container.style.maxWidth = 60 + 40 * getScrollProgress(image, screen.height, 1.1) + "%";
        })

        // Slider parallax
        sliders.forEach(slider => {
          const sliderElement = slider.querySelector('.swiper-container') as HTMLElement;
          sliderElement.style.transform = "translateX(" + -30 * getScrollProgress(slider, window.innerHeight / 2, 2) + "vw)";
        })
      }

      document.addEventListener('scroll', scrollAnimations)

      // Texts fade
      const observer = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            entry.target.querySelectorAll('.fade-element').forEach((el, index) => {
              if(entry.intersectionRatio >= 0.75) {
                if(el) {
                    if (entry.isIntersecting) {
                      setTimeout(() => {
                        el.classList.add('visible');
                      }, 200 * index);
                    }
                }
              }
              else {
                if(entry.boundingClientRect.top > 0)
                  el.classList.remove('visible');
              }
            })
          });
      }, {
        threshold: 0.75
      });

      document.querySelectorAll('section').forEach(el => observer.observe(el));
    })
  </script>
</body>
</html>
